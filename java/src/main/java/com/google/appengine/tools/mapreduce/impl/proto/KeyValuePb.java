package com.google.appengine.tools.mapreduce.impl.proto;

import com.google.protobuf.AbstractParser;
import com.google.protobuf.ByteString;
import com.google.protobuf.CodedInputStream;
import com.google.protobuf.Descriptors;
import com.google.protobuf.ExtensionRegistry;
import com.google.protobuf.ExtensionRegistryLite;
import com.google.protobuf.GeneratedMessage;
import com.google.protobuf.InvalidProtocolBufferException;
import com.google.protobuf.MessageOrBuilder;
import com.google.protobuf.Parser;
import com.google.protobuf.UnknownFieldSet;

import java.io.IOException;
import java.io.InputStream;
import java.util.Collections;
import java.util.List;

// Generated by the protocol buffer compiler. DO NOT EDIT!
// source: java/com/google/appengine/tools/mapreduce/impl/proto/kv.proto

@SuppressWarnings("all")
public final class KeyValuePb {
  private KeyValuePb() {}

  public static void registerAllExtensions(@SuppressWarnings("unused") ExtensionRegistry registry) {}

  public interface KeyValueOrBuilder extends MessageOrBuilder {

    // required bytes key = 1 [ctype = CORD];
    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    boolean hasKey();

    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    ByteString getKey();

    // required bytes value = 2 [ctype = CORD];
    /**
     * <code>required bytes value = 2 [ctype = CORD];</code>
     */
    boolean hasValue();

    /**
     * <code>required bytes value = 2 [ctype = CORD];</code>
     */
    ByteString getValue();
  }
  /**
   * Protobuf type {@code KeyValue}
   */
  public static final class KeyValue extends GeneratedMessage implements KeyValueOrBuilder {
    // Use KeyValue.newBuilder() to construct.
    private KeyValue(GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }

    private KeyValue(@SuppressWarnings("unused") boolean noInit) {
      this.unknownFields = UnknownFieldSet.getDefaultInstance();
    }

    private static final KeyValue defaultInstance;

    public static KeyValue getDefaultInstance() {
      return defaultInstance;
    }

    @Override
    public KeyValue getDefaultInstanceForType() {
      return defaultInstance;
    }

    @SuppressWarnings("hiding")
    private final UnknownFieldSet unknownFields;

    @java.lang.Override
    public final UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    public static final Descriptors.Descriptor getDescriptor() {
      return KeyValuePb.internal_static_KeyValue_descriptor;
    }

    @Override
    protected GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
      return KeyValuePb.internal_static_KeyValue_fieldAccessorTable.ensureFieldAccessorsInitialized(
          KeyValuePb.KeyValue.class, KeyValuePb.KeyValue.Builder.class);
    }

    public static Parser<KeyValue> PARSER = new AbstractParser<KeyValue>() {
      @Override
      public KeyValue parsePartialFrom(CodedInputStream input,
          ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(
              builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    @java.lang.Override
    public Parser<KeyValue> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    // required bytes key = 1 [ctype = CORD];
    public static final int KEY_FIELD_NUMBER = 1;
    private ByteString key_;

    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    @Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }

    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    @Override
    public ByteString getKey() {
      return key_;
    }

    // required bytes value = 2 [ctype = CORD];
    public static final int VALUE_FIELD_NUMBER = 2;
    private ByteString value_;

    /**
     * <code>required bytes value = 2 [ctype = CORD];</code>
     */
    @Override
    public boolean hasValue() {
      return ((bitField0_ & 0x00000002) == 0x00000002);
    }

    /**
     * <code>required bytes value = 2 [ctype = CORD];</code>
     */
    @Override
    public ByteString getValue() {
      return value_;
    }

    private void initFields() {
      key_ = ByteString.EMPTY;
      value_ = ByteString.EMPTY;
    }

    public static KeyValuePb.KeyValue parseFrom(ByteString data) throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static KeyValuePb.KeyValue parseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
        throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static KeyValuePb.KeyValue parseFrom(byte[] data) throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static KeyValuePb.KeyValue parseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
        throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static KeyValuePb.KeyValue parseFrom(InputStream input) throws java.io.IOException {
      return PARSER.parseFrom(input);
    }

    public static KeyValuePb.KeyValue parseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
        throws IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static KeyValuePb.KeyValue parseDelimitedFrom(InputStream input) throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }

    public static KeyValuePb.KeyValue parseDelimitedFrom(InputStream input,
        ExtensionRegistryLite extensionRegistry) throws IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }

    public static KeyValuePb.KeyValue parseFrom(CodedInputStream input) throws java.io.IOException {
      return PARSER.parseFrom(input);
    }

    public static KeyValuePb.KeyValue parseFrom(CodedInputStream input,
        ExtensionRegistryLite extensionRegistry) throws IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return Builder.create();
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder(KeyValuePb.KeyValue prototype) {
      return newBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return newBuilder(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     * Protobuf type {@code KeyValue}
     */
    public static final class Builder extends GeneratedMessage.Builder<Builder> implements
        KeyValuePb.KeyValueOrBuilder {
      public static final Descriptors.Descriptor getDescriptor() {
        return KeyValuePb.internal_static_KeyValue_descriptor;
      }

      @Override
      protected GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
        return KeyValuePb.internal_static_KeyValue_fieldAccessorTable.ensureFieldAccessorsInitialized(
            KeyValuePb.KeyValue.class, KeyValuePb.KeyValue.Builder.class);
      }

      // Construct using KV.KeyValue.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }

      private static Builder create() {
        return new Builder();
      }

      @Override
      public Builder clear() {
        super.clear();
        key_ = ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        value_ = ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @Override
      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      @Override
      public Descriptors.Descriptor getDescriptorForType() {
        return KeyValuePb.internal_static_KeyValue_descriptor;
      }

      @Override
      public KeyValuePb.KeyValue getDefaultInstanceForType() {
        return KeyValuePb.KeyValue.getDefaultInstance();
      }

      @Override
      public KeyValuePb.KeyValue build() {
        KeyValuePb.KeyValue result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public KeyValuePb.KeyValue buildPartial() {
        KeyValuePb.KeyValue result = new KeyValuePb.KeyValue(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.key_ = key_;
        if (((from_bitField0_ & 0x00000002) == 0x00000002)) {
          to_bitField0_ |= 0x00000002;
        }
        result.value_ = value_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      private int bitField0_;

      // required bytes key = 1 [ctype = CORD];
      private ByteString key_ = ByteString.EMPTY;

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      @Override
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      @Override
      public ByteString getKey() {
        return key_;
      }

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      public Builder setKey(ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        key_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }

      // required bytes value = 2 [ctype = CORD];
      private ByteString value_ = ByteString.EMPTY;

      /**
       * <code>required bytes value = 2 [ctype = CORD];</code>
       */
      @Override
      public boolean hasValue() {
        return ((bitField0_ & 0x00000002) == 0x00000002);
      }

      /**
       * <code>required bytes value = 2 [ctype = CORD];</code>
       */
      @Override
      public ByteString getValue() {
        return value_;
      }

      /**
       * <code>required bytes value = 2 [ctype = CORD];</code>
       */
      public Builder setValue(ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000002;
        value_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>required bytes value = 2 [ctype = CORD];</code>
       */
      public Builder clearValue() {
        bitField0_ = (bitField0_ & ~0x00000002);
        value_ = getDefaultInstance().getValue();
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:KeyValue)
    }

    static {
      defaultInstance = new KeyValue(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:KeyValue)
  }

  public interface KeyValuesOrBuilder extends MessageOrBuilder {

    // required bytes key = 1 [ctype = CORD];
    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    boolean hasKey();

    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    ByteString getKey();

    // repeated bytes value = 2 [ctype = CORD];
    /**
     * <code>repeated bytes value = 2 [ctype = CORD];</code>
     *
     * <pre>
     *Don't use 3.
     *</pre>
     */
    List<ByteString> getValueList();

    /**
     * <code>repeated bytes value = 2 [ctype = CORD];</code>
     *
     * <pre>
     *Don't use 3.
     *</pre>
     */
    int getValueCount();

    /**
     * <code>repeated bytes value = 2 [ctype = CORD];</code>
     *
     * <pre>
     *Don't use 3.
     *</pre>
     */
    ByteString getValue(int index);
  }
  /**
   * Protobuf type {@code KeyValues}
   */
  public static final class KeyValues extends GeneratedMessage implements KeyValuesOrBuilder {
    // Use KeyValues.newBuilder() to construct.
    private KeyValues(GeneratedMessage.Builder<?> builder) {
      super(builder);
      this.unknownFields = builder.getUnknownFields();
    }

    private KeyValues(@SuppressWarnings("unused") boolean noInit) {
      this.unknownFields = UnknownFieldSet.getDefaultInstance();
    }

    private static final KeyValues defaultInstance;

    public static KeyValues getDefaultInstance() {
      return defaultInstance;
    }

    @Override
    public KeyValues getDefaultInstanceForType() {
      return defaultInstance;
    }

    @SuppressWarnings("hiding")
    private final UnknownFieldSet unknownFields;

    @java.lang.Override
    public final UnknownFieldSet getUnknownFields() {
      return this.unknownFields;
    }

    public static final Descriptors.Descriptor getDescriptor() {
      return KeyValuePb.internal_static_KeyValues_descriptor;
    }

    @Override
    protected GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
      return KeyValuePb.internal_static_KeyValues_fieldAccessorTable.ensureFieldAccessorsInitialized(
          KeyValuePb.KeyValues.class, KeyValuePb.KeyValues.Builder.class);
    }

    public static Parser<KeyValues> PARSER = new AbstractParser<KeyValues>() {
      @Override
      public KeyValues parsePartialFrom(CodedInputStream input,
          ExtensionRegistryLite extensionRegistry) throws InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (IOException e) {
          throw new InvalidProtocolBufferException(e.getMessage()).setUnfinishedMessage(
              builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    @Override
    public Parser<KeyValues> getParserForType() {
      return PARSER;
    }

    private int bitField0_;
    // required bytes key = 1 [ctype = CORD];
    public static final int KEY_FIELD_NUMBER = 1;
    private ByteString key_;

    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    @Override
    public boolean hasKey() {
      return ((bitField0_ & 0x00000001) == 0x00000001);
    }

    /**
     * <code>required bytes key = 1 [ctype = CORD];</code>
     */
    @Override
    public ByteString getKey() {
      return key_;
    }

    // repeated bytes value = 2 [ctype = CORD];
    public static final int VALUE_FIELD_NUMBER = 2;
    private List<ByteString> value_;

    /**
     * <code>repeated bytes value = 2 [ctype = CORD];</code>
     *
     * <pre>
     *Don't use 3.
     *</pre>
     */
    @Override
    public List<ByteString> getValueList() {
      return value_;
    }

    /**
     * <code>repeated bytes value = 2 [ctype = CORD];</code>
     *
     * <pre>
     *Don't use 3.
     *</pre>
     */
    @Override
    public int getValueCount() {
      return value_.size();
    }

    /**
     * <code>repeated bytes value = 2 [ctype = CORD];</code>
     *
     * <pre>
     *Don't use 3.
     *</pre>
     */
    @Override
    public ByteString getValue(int index) {
      return value_.get(index);
    }

    private void initFields() {
      key_ = ByteString.EMPTY;
      value_ = Collections.emptyList();
    }

    public static KeyValuePb.KeyValues parseFrom(ByteString data) throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static KeyValuePb.KeyValues parseFrom(ByteString data, ExtensionRegistryLite extensionRegistry)
        throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static KeyValuePb.KeyValues parseFrom(byte[] data) throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }

    public static KeyValuePb.KeyValues parseFrom(byte[] data, ExtensionRegistryLite extensionRegistry)
        throws InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }

    public static KeyValuePb.KeyValues parseFrom(InputStream input) throws IOException {
      return PARSER.parseFrom(input);
    }

    public static KeyValuePb.KeyValues parseFrom(InputStream input, ExtensionRegistryLite extensionRegistry)
        throws IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static KeyValuePb.KeyValues parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return PARSER.parseDelimitedFrom(input);
    }

    public static KeyValuePb.KeyValues parseDelimitedFrom(InputStream input,
        ExtensionRegistryLite extensionRegistry) throws IOException {
      return PARSER.parseDelimitedFrom(input, extensionRegistry);
    }

    public static KeyValuePb.KeyValues parseFrom(CodedInputStream input) throws IOException {
      return PARSER.parseFrom(input);
    }

    public static KeyValuePb.KeyValues parseFrom(CodedInputStream input,
        ExtensionRegistryLite extensionRegistry) throws IOException {
      return PARSER.parseFrom(input, extensionRegistry);
    }

    public static Builder newBuilder() {
      return Builder.create();
    }

    @Override
    public Builder newBuilderForType() {
      return newBuilder();
    }

    public static Builder newBuilder(KeyValuePb.KeyValues prototype) {
      return newBuilder().mergeFrom(prototype);
    }

    @Override
    public Builder toBuilder() {
      return newBuilder(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }

    /**
     * Protobuf type {@code KeyValues}
     */
    public static final class Builder extends GeneratedMessage.Builder<Builder> implements
        KeyValuePb.KeyValuesOrBuilder {
      public static final Descriptors.Descriptor getDescriptor() {
        return KeyValuePb.internal_static_KeyValues_descriptor;
      }

      @Override
      protected GeneratedMessage.FieldAccessorTable internalGetFieldAccessorTable() {
        return KeyValuePb.internal_static_KeyValues_fieldAccessorTable.ensureFieldAccessorsInitialized(
            KeyValuePb.KeyValues.class, KeyValuePb.KeyValues.Builder.class);
      }

      // Construct using KV.KeyValues.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }

      private void maybeForceBuilderInitialization() {
        if (GeneratedMessage.alwaysUseFieldBuilders) {
        }
      }

      private static Builder create() {
        return new Builder();
      }

      @Override
      public Builder clear() {
        super.clear();
        key_ = ByteString.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000001);
        value_ = Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      @Override
      public Builder clone() {
        return create().mergeFrom(buildPartial());
      }

      @Override
      public Descriptors.Descriptor getDescriptorForType() {
        return KeyValuePb.internal_static_KeyValues_descriptor;
      }

      @Override
      public KeyValuePb.KeyValues getDefaultInstanceForType() {
        return KeyValuePb.KeyValues.getDefaultInstance();
      }

      @Override
      public KeyValuePb.KeyValues build() {
        KeyValuePb.KeyValues result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @Override
      public KeyValuePb.KeyValues buildPartial() {
        KeyValuePb.KeyValues result = new KeyValuePb.KeyValues(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) == 0x00000001)) {
          to_bitField0_ |= 0x00000001;
        }
        result.key_ = key_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          value_ = java.util.Collections.unmodifiableList(value_);
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.value_ = value_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      private int bitField0_;

      // required bytes key = 1 [ctype = CORD];
      private ByteString key_ = ByteString.EMPTY;

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      @Override
      public boolean hasKey() {
        return ((bitField0_ & 0x00000001) == 0x00000001);
      }

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      @Override
      public ByteString getKey() {
        return key_;
      }

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      public Builder setKey(ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000001;
        key_ = value;
        onChanged();
        return this;
      }

      /**
       * <code>required bytes key = 1 [ctype = CORD];</code>
       */
      public Builder clearKey() {
        bitField0_ = (bitField0_ & ~0x00000001);
        key_ = getDefaultInstance().getKey();
        onChanged();
        return this;
      }

      // repeated bytes value = 2 [ctype = CORD];
      private List<ByteString> value_ = java.util.Collections.emptyList();

      private void ensureValueIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          value_ = new java.util.ArrayList<ByteString>(value_);
          bitField0_ |= 0x00000002;
        }
      }

      /**
       * <code>repeated bytes value = 2 [ctype = CORD];</code>
       *
       * <pre>
       *Don't use 3.
       *</pre>
       */
      @Override
      public List<ByteString> getValueList() {
        return Collections.unmodifiableList(value_);
      }

      /**
       * <code>repeated bytes value = 2 [ctype = CORD];</code>
       *
       * <pre>
       *Don't use 3.
       *</pre>
       */
      @Override
      public int getValueCount() {
        return value_.size();
      }

      /**
       * <code>repeated bytes value = 2 [ctype = CORD];</code>
       *
       * <pre>
       *Don't use 3.
       *</pre>
       */
      @Override
      public ByteString getValue(int index) {
        return value_.get(index);
      }

      /**
       * <code>repeated bytes value = 2 [ctype = CORD];</code>
       *
       * <pre>
       *Don't use 3.
       *</pre>
       */
      public Builder setValue(int index, ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureValueIsMutable();
        value_.set(index, value);
        onChanged();
        return this;
      }

      /**
       * <code>repeated bytes value = 2 [ctype = CORD];</code>
       *
       * <pre>
       *Don't use 3.
       *</pre>
       */
      public Builder addValue(ByteString value) {
        if (value == null) {
          throw new NullPointerException();
        }
        ensureValueIsMutable();
        value_.add(value);
        onChanged();
        return this;
      }

      /**
       * <code>repeated bytes value = 2 [ctype = CORD];</code>
       *
       * <pre>
       *Don't use 3.
       *</pre>
       */
      public Builder addAllValue(Iterable<? extends ByteString> values) {
        ensureValueIsMutable();
        super.addAll(values, value_);
        onChanged();
        return this;
      }

      /**
       * <code>repeated bytes value = 2 [ctype = CORD];</code>
       *
       * <pre>
       *Don't use 3.
       *</pre>
       */
      public Builder clearValue() {
        value_ = java.util.Collections.emptyList();
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }

      // @@protoc_insertion_point(builder_scope:KeyValues)
    }

    static {
      defaultInstance = new KeyValues(true);
      defaultInstance.initFields();
    }

    // @@protoc_insertion_point(class_scope:KeyValues)
  }

  private static Descriptors.Descriptor internal_static_KeyValue_descriptor;
  private static GeneratedMessage.FieldAccessorTable internal_static_KeyValue_fieldAccessorTable;
  private static Descriptors.Descriptor internal_static_KeyValues_descriptor;
  private static GeneratedMessage.FieldAccessorTable internal_static_KeyValues_fieldAccessorTable;

  public static Descriptors.FileDescriptor getDescriptor() {
    return descriptor;
  }

  private static Descriptors.FileDescriptor descriptor;
  static {
    java.lang.String[] descriptorData =
        {"\n=java/com/google/appengine/tools/mapred"
            + "uce/impl/proto/KV.proto\".\n\010KeyValue\022\017\n\003k"
            + "ey\030\001 \002(\014B\002\010\001\022\021\n\005value\030\002 \002(\014B\002\010\001\"/\n\tKeyVa"
            + "lues\022\017\n\003key\030\001 \002(\014B\002\010\001\022\021\n\005value\030\002 \003(\014B\002\010\001"
            + "B\002H\002"};
    Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new Descriptors.FileDescriptor.InternalDescriptorAssigner() {
          @Override
          public ExtensionRegistry assignDescriptors(Descriptors.FileDescriptor root) {
            descriptor = root;
            internal_static_KeyValue_descriptor = getDescriptor().getMessageTypes().get(0);
            internal_static_KeyValue_fieldAccessorTable = new GeneratedMessage.FieldAccessorTable(
                internal_static_KeyValue_descriptor, new java.lang.String[] {"Key", "Value",});
            internal_static_KeyValues_descriptor = getDescriptor().getMessageTypes().get(1);
            internal_static_KeyValues_fieldAccessorTable = new GeneratedMessage.FieldAccessorTable(
                internal_static_KeyValues_descriptor, new java.lang.String[] {"Key", "Value",});
            return null;
          }
        };
    Descriptors.FileDescriptor.internalBuildGeneratedFileFrom(descriptorData,
        new Descriptors.FileDescriptor[] {}, assigner);
  }

  // @@protoc_insertion_point(outer_class_scope)
}
